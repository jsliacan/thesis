In Chapter~\ref{chap:packsmall}, we used the flag algebras method when bounding packing densities of small permutations. The method transforms a combinatorial problem to a semidefinite one. See Section~\ref{sec:FA} for details about the flag algebras framework. Since flag algebras are algorithmic and syntax-based, they are suitable for a computer implementation.

Permpack~\cite{permpack} is a lightweight implementation of flag algebras as a package on top of Sage~\cite{sagemath}. Permpack is exclusively for flag algebras computations on permutations. The syntax is supposed to resemble that of Flagmatic as much as possible, where Flagmatic is a flag algebras software for graphs, 3-uniform hypergraphs, directed graphs, and multigraphs developed by Vaughan~\cite{flagmatic}. A version of Flagmatic in its original form with minimal updates (by me) to maintain compatibility with new versions of Sage is available from \url{https://github.com/jsliacan/flagmatic}. Similarly, the source code of Permpack can be found in its Github repository \url{https://github.com/jsliacan/permpack}. 

\section{Set-up}
\label{sec:permpack-setup}

To use Permpack, you will need a UNIX machine (a flavour of Linux or a Mac) with a recent (7.5+) Sage installed on it (note that Sage has its own list of dependencies). Additionally, one also needs a semidefinite solver to which Permpack passes the constructed semidefinite problem.

Installing Sage from source is recommended if speed is an issue, which it is in most interesting cases. This can take up to a day on a regular consumer laptop! Instructions can be found here: \url{http://doc.sagemath.org/html/en/installation/source.html}. It is useful to specify the number of jobs to run in parallel when making Sage. This can be done with the following command:\\ \shellcmd{MAKE=`make -jNUM' make}, where \texttt{NUM} is the number of jobs you can afford simultaneously. Once Sage is up and running, you will need to place the solver's binary file in the \texttt{\$PATH}, so that Sage can find it when needed. Usually \texttt{/user/local/bin} works. At this point, the set-up should be complete.


\subsection{Solvers}
\label{sec:permpack-solvers}

There are two semidefinite solvers that are currently supported by Permpack: CSDP~\cite{csdp} and SDPA-DD~\cite{sdpa}. It is advisable to install CSDP from source (including LAPACK/BLAS libraries) in order to make the best use of the resources on the computer that you are using. See the instructions in the INSTALL file included with the source distribution on Github: \url{https://github.com/coin-or/Csdp}.

Among other available solvers are SeDuMi, SDPT3, DSDP, and CVXOPT. These are all based on the interior-point method. First order method is at the core of SCS solver. In practice, CSDP and various precisions of SDPA solver (SDPA-DD, SDPA-QD) perform reasonably well both in terms of accuracy and speed. Permpack supports CSDP (\texttt{csdp}) and SDPA-DD (\texttt{sdpa\_dd}) options for the \texttt{solver} argument.

\begin{note}
When using SDPA double precision solver, the numerical solution matrices that the solver returns are not always positive semidefinite. There may be eigenvalues which are negligibly negative, say $-10^{-20}$. This needs to be treated before further processing because we use numpy's Cholesky decomposition in the next step. Hence, Permpack cannot currently deal with negative eigenvalues, however small.
\end{note}

\section{Usage}
\label{sec:permpack-usage}

It is ideal to start Permpack from \texttt{/path/to/permpack/pkg/} directory. Once there, type \texttt{sage}. This should start Sage and you should see something similar to Listing~\ref{lst:sage}.
\lstsetbash \lstset{caption={Starting Sage.}, label={lst:sage}}
\begin{lstlisting}
-----------------------------------------------------------------
| Sage Version 8.0, Release Date: 2017-07-21                    |
| Type "notebook()" for the browser-based notebook interface.   |
| Type "help()" for help.                                       |
-----------------------------------------------------------------
sage:
\end{lstlisting}

You can test that things were loaded and that Sage can see your SDP solver by running a small example as in Listing~\ref{lst:ex132}.
%\lstset{language=python, basicstyle=\ttfamily\scriptsize, deletekeywords={local, help}, keywordstyle=\color{keywords}, commentstyle=\color{comments}, stringstyle=\color{black}, numbers=left, stepnumber=1, frame=single, showstringspaces=false, caption={Using Permpack to give an upper bound (numerical) for the packing density of 132.}, label={lst:ex132}}
\lstsetsage \lstset{caption={Floating point upper bound on the packing density of 132.}, label={lst:ex132}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem(3, density_pattern="132")
sage: p.solve_sdp(solver="csdp")
\end{lstlisting}
The output should resemble the one in Listing~\ref{lst:outputex132}, with the bound being reported as \texttt{-4.6410162e-01} (the minus sign is due to the internal representation of the SDP problem in CSDP as maximization versus minimization). Clearly, the result is the floating point representation of $2\sqrt{3}-3$, the packing density of 132. 
\lstset{caption={Output from Permpack after commands from Listing~\ref{lst:ex132}.}, label={lst:outputex132}}
\begin{lstlisting}
Generating admissible permutations... OK.
Generating types... OK.
Generating flags... OK.
Expressing density pattern as a linear combination of permutations... OK.
------------------------------------------------
Generated:
6 admissible permutations.
1 types of order 1, with [4] flags.
------------------------------------------------
/path/to/Github/permpack/pkg/../store/FP-N3.txt
Loading flag_products from file... OK.
Writing SDP input file... OK.
Solving SDP problem...
Iter:  0 Ap: 0.00e+00 Pobj: -1.200000e+02 Ad: 0.00e+00 Dobj:  0.000000e+00 
Iter:  1 Ap: 9.68e-01 Pobj: -2.014663e+02 Ad: 9.36e-01 Dobj:  9.579035e+00 
Iter:  2 Ap: 1.00e+00 Pobj: -1.569510e+02 Ad: 1.00e+00 Dobj:  9.009622e+00 
Iter:  3 Ap: 9.92e-01 Pobj: -8.120415e+00 Ad: 1.00e+00 Dobj:  5.149692e-01 
Iter:  4 Ap: 9.98e-01 Pobj: -1.207828e+00 Ad: 1.00e+00 Dobj: -3.893852e-02 
Iter:  5 Ap: 1.00e+00 Pobj: -9.312314e-01 Ad: 7.51e-01 Dobj: -3.164694e-01 
Iter:  6 Ap: 9.92e-01 Pobj: -5.212294e-01 Ad: 1.00e+00 Dobj: -4.256196e-01 
Iter:  7 Ap: 1.00e+00 Pobj: -4.689616e-01 Ad: 1.00e+00 Dobj: -4.609830e-01 
Iter:  8 Ap: 9.99e-01 Pobj: -4.643160e-01 Ad: 1.00e+00 Dobj: -4.639517e-01 
Iter:  9 Ap: 9.99e-01 Pobj: -4.641108e-01 Ad: 1.00e+00 Dobj: -4.640964e-01 
Iter: 10 Ap: 1.00e+00 Pobj: -4.641020e-01 Ad: 1.00e+00 Dobj: -4.641023e-01 
Iter: 11 Ap: 1.00e+00 Pobj: -4.641016e-01 Ad: 1.00e+00 Dobj: -4.641016e-01 
Iter: 12 Ap: 9.56e-01 Pobj: -4.641016e-01 Ad: 9.60e-01 Dobj: -4.641016e-01 
Success: SDP solved
Primal objective value: -4.6410162e-01 
Dual objective value: -4.6410162e-01 
Relative primal infeasibility: 4.65e-14 
Relative dual infeasibility: 1.67e-10 
Real Relative Gap: 3.68e-10 
XZ Relative Gap: 6.14e-10 
DIMACS error measures: 4.65e-14 0.0e+00 3.10e-10 0.0e+00 3.68e-10 6.14e-10
Finished. OK.
\end{lstlisting}

Before using any of the module, it is necessary to load it. This is done by the command in Sage interpreter given in Listing~\ref{lst:loadpermpack}.
\lstsetsage \lstset{caption={Loading permpack module.}, label={lst:loadpermpack}}
\begin{lstlisting}
sage: from permpack.all import *
\end{lstlisting}

\subsection{Entering the problem into Permpack}

Assuming that the permpack module is loaded, the user is concerned with only one class: \texttt{PermProblem}. Everything is done in terms of solving this permutation problem. It is easily created (and assigned to a variable through which it is accessed later) as in Listing~\ref{lst:createproblem}. 
\lstsetsage \lstset{caption={Creating a permutation problem to solve.}, label={lst:createproblem}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem()
\end{lstlisting}

The constructor for the \texttt{PermProblem} class takes at most three arguments (described in Table~\ref{tab:argspermproblem}), none of which is mandatory. The \texttt{\_\_init\_\_()} method of \texttt{PermProblem} assumes that the length of admissible permutations is zero, the density pattern is 21, and the set of forbidden permutations is empty. In other words, the default \texttt{PermProblem} object is just a dummy permutation problem. Therefore, one usually wants to specify at least the length of admissible permutations \texttt{N} and the \emph{density pattern}.

\begin{table}[ht]
  \centering
    \begin{tabular}{r|l}
      \textbf{Argument} & \textbf{Description}\\
      \hline
      \texttt{N} & length of each admissible permutation\\
      \texttt{forbid} & list of forbidden permutations\\
      \texttt{density\_pattern} & linear combination of permutations whose density we maximize
    \end{tabular}
    \caption{Arguments to the \texttt{PermProblem} constructor.}
    \label{tab:argspermproblem}
\end{table}

For example, when solving the packing problem for 132, it is sufficient to consider $\texttt{N}=3$ (see example in Section~\ref{sec:example}). Notice that $\texttt{N}<3$ would not be useful as the density of 132 in any permutation of length less than 3 is zero, hence the density behaviour of 132 would not be captured in, say, admissible permutations of length two: $\P_2 = \{12,21\}$. Usually, higher \texttt{N} yields more precise results (unless the problem is intrinsically hard for flag algebras method, as could be the case when the bound is attained by more than one extremal construction). To keep the section self-contained, we give an example of how to solve the packing problem for 132 via Permpack. See Listing~\ref{lst:permpack:pack132}.

\lstsetsage \lstset{caption={Setting up packing problem for the 132 pattern.}, label={lst:permpack:pack132}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem(3, forbid=[], density_pattern="132")
\end{lstlisting}
The response from Permpack should resemble the output in Listing~\ref{lst:permpack:out132}.
\lstset{caption={Response from Permpack when setting up the packing problem for 132.}, label={lst:permpack:out132}}
\begin{lstlisting}
Generating admissible permutations... OK.
Generating types... OK.
Generating flags... OK.
Expressing density pattern as a linear combination of permutations... OK.
------------------------------------------------
Generated:
6 admissible permutations.
1 types of order 1, with [4] flags.
------------------------------------------------
/path/to/Github/permpack/pkg/../store/FP-N3.txt
Loading flag_products from file... OK.
\end{lstlisting}
Notice, in particular, the lines 10-11:
\lstset{numbers=none, frame=none, caption={}, label={lst:permpack:excerpt}}
\begin{lstlisting}
/path/to/Github/permpack/pkg/../store/FP-N3.txt
Loading flag_products from file... OK.
\end{lstlisting}
Permpack does not recompute flag products if the problem (requiring the same flag products) was already encountered before. This is to save time. We briefly mention this in Section~\ref{sec:permpack-misc}.

Let us now comment on the format of the input to the \texttt{PermProblem} constructor. 
\begin{itemize}
\item \texttt{N}: Permpack only accepts integers. When \texttt{N} gets too large (say 9), the computations become very slow already when computing flag products. It is very likely that even if you manage to wait long enough to compute these, the SDP problem will be so large that you will run out of memory (for instance).
\item \texttt{forbid}: Permpack accepts a list of permutations. Do make sure that each of them has length at most \texttt{N}. Otherwise it is impossible to exclude them from the computations.
\item \texttt{density\_pattern}: Permpack accepts a few different inputs. Firstly, a solo permutation either as a list of integers, \texttt{[1,3,2]}, or as a string,\texttt{"132"}, is fine. However, it is possible to want to maximize the density of, say, $1/2\cdot 132 + 1/2\cdot 231$. This can also be done. Permpack takes such input as a list of tuples, each touple of length two with the first entry a permutation (either as a list of integers or as a string) and the second entry a coefficient (as a fraction or a floating point number). For example, the following inputs are all equivalent (although the last one is scaled differently -- the problem has the same maximizer(s), just different packing density of the \texttt{density\_pattern}):
\begin{itemize}
\item[$\star$] \texttt{density\_pattern=[([1,3,2],1/2),([2,1,3],1/2)]}
\item[$\star$] \texttt{density\_pattern=[("132",0.5),("213",0.5)]}
\item[$\star$] \texttt{density\_pattern=[("132",1),("213",1)]}
\end{itemize}
\end{itemize}

\subsection{Solving SDP}
The next method one needs to call on the \texttt{PermProblem} is \texttt{solve\_sdp()}. As usual, it is possible to call this method without any arguments. In such case, the solver defaults to CSDP. If one wants a double precision solver SDPA-DD, argument needs to be passed with that option: \texttt{solve\_sdp(solver="sdpa\_dd")}. First, the method \texttt{solve\_sdp()} writes and input file to the SDP solver. The default input filename is \texttt{sdp.dat-s}. If you wish for a different name pass an additional argument to the \texttt{solve\_sdp()} method specifying the filename, e.g. \texttt{input\_file="myfile.dat-s"}. Make sure that the filename ends with \texttt{.dat-s} suffix to be recognized as a sparse data file by the solver. The \texttt{solve\_sdp()} method then passes the information to the SDP solver together with the output filename, where the solution to the semidefinite problem will be stored. The default output filename is \texttt{sdp.out}. If you wish this file to be named differently, you need to pass an additional argument to the \texttt{solve\_sdp()} method specifying your preferred filename: \texttt{output\_file="myfile.out"}, where the \texttt{.out} extension is just a convention. All these files are stored in the current working directory to be easily accessible if one wants to peruse them manually. Once the method passes everything to the solver, it can take a long time before a solution is found by the solver. You will see the progress on your screen as the output from the solver is not suppressed. Once the solver finished, you'll be able to see the floating point bound that was found. The next step is rounding the floating point solution matrices to have exact entries such that they stay positive semidefinite and the new exact bound is as good as possible. An example call to \texttt{solve\_sdp()} is in Listing~\ref{lst:permpack:solvesdp}.

\lstsetsage \lstset{caption={Packing 132. Code up to calling the SDP solver. You should see \texttt{myfile.dat-s} and \texttt{myfile.out} in your current working directory after executing the following code.}, label={lst:permpack:solvesdp}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem(3, density_pattern="132")
sage: p.solve_sdp(solver="csdp",
                  input_file="myfile.dat-s",
                  output_file="myfile.out")
\end{lstlisting}

\subsection{Assumptions}
A feature of Permpack that is worth mentioning, albeit briefly, are assumptions. Imagine one wants to add additional density assumptions on various pattern densities. There are various natural examples, but a small and easily checkable one is the following. Imagine that you want to find the packing density of $12$ in $123$-free permutations. However, you insist that the density of $312$ is at least $1/5$ (notice that its density would be $0$ in the maximiser of $12$ in $123$-free permutations). Therefore, you are essentially forcing the problem away from the usual optimum. It is not immediately obvious what the answer is, and the number that Permpack gives will probably not make you wiser. It was an arbitrarily chosen problem to illustrate a feature. However, you can certainly see that the value Permpack gives you is smaller than $1/2$, which would be the packing density of $12$ in $123$-free permutations. See the code snippet in Listing~\ref{lst:permpack:assumption_in} that asks Permpack to compute this example for us. The structure of the command is the following. Use the \texttt{add\_assumption} method of the \texttt{PermProblem} class. It takes two arguments: a list of pairs $(\sigma,c_\sigma)$ and a bound $b$. The idea is to bound a linear combination of permutation densities, such as $c_{123}p(123,P) + c_{321}p(321,P) \geq b$, where the inequality holds for every admissible $P$. Clearly, this can be encoded as a vector of pairs $(\sigma,c_\sigma)$ and an additional bound $b$. In our example, $\sigma = 312$, $c_{312} = 1$, and $b = 1/5$. 

\lstsetsage \lstset{caption={Forbid $123$, maximise $12$ under the constraint that $p(312) \geq 1/5$.}, label={lst:permpack:assumption_in}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem(3, forbid=["123"], density_pattern="12")
sage: p.add_assumption([("312",1)], 1/5)
sage: p.solve_sdp()
\end{lstlisting}

The critical excerpt from the output is provided below, in Listing~\ref{lst:permpack:assumption_out}.

\lstset{caption={The interesing part of Permpack's output for the problem in Listing~\ref{lst:permpack:assumption_in}.}, label={lst:permpack:assumption_out}}
\begin{lstlisting}
Success: SDP solved
Primal objective value: -3.4261685e-01 
Dual objective value: -3.4261686e-01 
Relative primal infeasibility: 9.25e-15 
Relative dual infeasibility: 6.65e-09 
Real Relative Gap: -1.16e-08 
XZ Relative Gap: 7.77e-09 
DIMACS error msrs: 9.25e-15 0.00e+00 1.39e-08 0.00e+00 -1.16e-08 7.77e-09
Finished. OK.
\end{lstlisting}

\subsection{Rounding}
The next aspect to discuss is the rounding procedure. As is obvious from above, a SDP solver returns matrices whose entries are floating point values. They are inexact and do not prove anything. Therefore, we need to convert these matrices to other matrices, preserving positive semi-definiteness and ideally stay as close to the desired bound on our problem as possible. We call the procedure of converting floating-point matrices to ``exact'' matrices, \emph{rounding} and is done by \texttt{exactify()} method in Permpack. It is quite basic at this point. We only worry about preserving the positive-semidefiniteness and hope that if the rounded matrix is entry-wise close to the original one, then the bound will not be off by too much. In practice, this works reasonably well. The method \texttt{exactify} takes several optional arguments which can fine-tune the ``precision'' with thich the rounding is done, e.g. eigenvalues close to zero are rounded to zero if they are close enough (this is the parameter \texttt{recognition\_precision} passed to \texttt{exactify}; another parameter is \texttt{rounding\_precision} and it specifies the denominator when rounding the entries of $L'$ in the Cholesky decomposition of a floating-point $Q'$ to rational quantities). We give a shared example for rounding and issuing certificates in Subsection~\ref{subsec:certificates}, see Listing~\ref{lst:permpack:exactify_in} and~\ref{lst:permpack:exactify_out} for input and output, respectively.

\subsection{Certificates}
\label{subsec:certificates}
The last critical part of Permpack that the user should be aware of are certificates. These are human readable files that store information necessary to verify the results obtained by Permpack. The key idea being that it is significantly easier to check if given matrices solve a SDP problem than finding those matrices in the first place. Therefore, the class \texttt{PermProblem} has a method \texttt{write\_certificate} which takes filename you want your certificate to have. It will be written into the current directory (so make sure you have writing permissions there). The certificate is a JSON file and is easy to read in and process. It contains the following information:
\begin{enumerate}
\item admissible permutations
\item flags
\item types
\item matrices $L$
\item bound (rational)
\end{enumerate}
Notice that as things currently stand, rounding (recall \texttt{exactify()} method) is done via Cholesky decomposition of the SDP $Q$ matrices. Therefore, every floating-point $Q' = L'L'^T$ is stored as the rounded version of $L'$ from which a rounded version of $Q'$ can be recovered. The example below shows how to round the SDP matrices and issue a certificate for your problem.

\lstsetsage \lstset{caption={We want eigenvalues smaller than $10^{-6}$ to be rounded to $0$ and the denominator for rounding to be $10^{10}$.}, label={lst:permpack:exactify_in}}
\begin{lstlisting}
sage: from permpack.all import *
sage: p = PermProblem(3, forbid=["123"], density_pattern="12")
sage: p.solve_sdp()
sage: p.exactify(recognition_precision=10e-6, rounding_precision=10e10)
sage: p.write_certificate("babyproblem.cert")
\end{lstlisting}

\lstset{caption={The interesing part of Permpack's output for the problem in Listing~\ref{lst:permpack:exactify_in}.}, label={lst:permpack:exactify_out}}
\begin{lstlisting}
...
Success: SDP solved
Primal objective value: -5.0000001e-01 
Dual objective value: -5.0000001e-01 
Relative primal infeasibility: 9.44e-16 
Relative dual infeasibility: 6.32e-09 
Real Relative Gap: -9.94e-10 
XZ Relative Gap: 6.94e-09 
DIMACS error msrs: 9.44e-16 0.00e+00 1.19e-08 0.00e+00 -9.94e-10 6.94e-09
...
Transforming floating-point matrices to rational matrices...
Reading output of the CSDP solver... OK.
Rounding Q matrices... OK.
Computing exact bound...
[OK]   Done. Exact bound is roughly 0.5000000043. Access it from
self._exact_bound.
Writing certificate into file... 
[OK]   Certificate written successfully to babyproblem.cert.
\end{lstlisting}


\section{Miscellaneous}
\label{sec:permpack-misc}
Here are a couple of remarks about Permpack to help you understand mysteriously looking output or behaviour of the package.

First, Permpack stores your computations if they are new. Indeed, when you clone the repository, it comes with some clumsily big files containing flag products for particular problems. Flag products are expensive to compute and at some point it becomes useful to store them and next time only load them from file. We intentionally did not choose any database storage in order for the files to be human readable. They are plain text files. 

Second, Permpack does make small use of multiprocessing when computing flag products. Maybe it would be better to use multiple threads instead, but this is something to consider at a later point in time if Permpack ever gets rewritten. The parallelization offers a modest speed-up if the machine has several cores. No miracles.

\section{Conclusion}

There are several hidden features of Permpack that would require longer discussion of the underlying Flag Algebras method. For instance, one can access slack variables of an SDP problem and, provided the bound is tight, obtain information about which admissible permutations do not asymptotically appear in any extremal construction for the problem. Additionally, there are hidden variables starting with an underscore (\texttt{\_}) that give the user access to intermediate computations and auxiliary variables. These can be useful in certain circumstances. The Flag Algebras method offers various insights into the problem through the computations that are performed on the way to obtaining a sharp bound. For discussion about these, follow the references in Section~\ref{sec:FA}. 

Permpack's functionality could be extended in many directions. From more general assumptions (I have implemented theses in Flagmatic for hypergraphs), through supply of extremal constructions that help with rounding (see the original Flagmatic~\cite{flagmatic}), to a more complete rounding procedure. Also, it is quite possible that, as in case of graphs, there are automated ways to determine various levels of stability of extremal constructions --- see a recent preprint~\cite{olegmekostas}. 

Finally, I would like to invite programmers to take a look at Permpack. There are areas which require no knowledge of Flag Algebras. For instance, at the end, solutions need to be rounded -- by this we mean converted from floating-point matrices to either matrices with rational entries or entries from some particular extension of rationals. These computations are not at all trivial, but do not depend on the idea of Flag Algebras. One only needs to understand the format of the SDP (see Section~\ref{sec:FA}, towards the end). Given an efficient rounding procedure, many problems would be automated from the input line all the way to the certificate stage. A good example of a worthy contribution is by Eric Zhang who simply wrote a more efficient \texttt{normalize} function which is used inside loops in critical computations. There must be many such inefficiencies and removing them often requires no knowledge of Flag Algebras. 
